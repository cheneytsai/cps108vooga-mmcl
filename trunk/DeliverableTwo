Team MMCL: 2150
Lisa Gutermuth, Megan Heysham, Cheney Tsai, Michael Yu
This is best viewed from our website, which provides images and appropriate
text wrapping.

The main program will create a Frame.
This Frame will display a menu bar and a Canvas.

Menu bar:
The menu bar will contain the following options:
    New Game (only works when the Canvas method isGameInProgress returns true,
    i.e, when the user is currently on a level.
    Instructions (displays the instructions specific to the game currently being
    played, or about using the Arcade in general if the user is still on the
    main menu)
    High Score (displays the high scores from the current game if the user has
    already selected a game)
    Quit (quits the program; this is very important)

Canvas:
The Canvas will contain an instance variable myActive which will be the
currently displayed content for the Canvas. MyActive subclasses Canvas (in order
to draw easily and correctly) and will currently be either a Menu or a
LevelViewer.
Canvas also contains a method to change the value of myActive.
Each subclass of Canvas contains a myCanvas variable. Thus the Canvas and its
myActive are tied to each other and are able to reference each other. The value
of myActive is changed when switching between Menus or between a Menu and
LevelViewer (when Play Game is selected from a menu or when New Game is selected
from the menu during game play).

Menu (subclass of Canvas, considering changing to JPanel?):
A Menu is created with its title and a Canvas.
Our original idea was to also subclass Menu for each game and code the menu
options for each game.
However, now we are hoping to parse from a file to get information on what the
menu options will be, where they will be located, and what each menu option will
do when selected. We will have a map of each menu option to an Action which will
be executed when that option in clicked on, via reflection. For instance, Quit
will map to the Quit Action.
The options will be drawn in their given location, based on the text file.
Uses mouseListeners to select menu options.


LevelViewer (subclass of Canvas, considering changing to JPanel?):
A LevelViewer is created with its game name, level name, the current score, and
a Canvas.
The LevelViewer creates a new GameModel, which contains all the Actors needed
for this level.
Loops through the Actors and draws them along with the background and
InformationPanel
It contains and draws an InformationPanel (using the paint method of
InformationPanel).
Has a keyListener to let Actors make the decision on whether or not they need to
respond to the keyPresses.

InformationPanel (subclass of JPanel):
The InformationPanel will display, for example, the score.
The Information Panel contains its location and a paint method
It can contain the score, current level, next piece to appear, game name, arcade
name, etc.
Subclassed for each game?






Playing the game:
(2150menu)
Original view (see Frame (including menu bar), Canvas, and Menu)
Selecting a game title changes myActive in the Canvas to a Menu for that game
Quit quits the game (go figure).

(Arkanoidmenu)
Game menu:
Play Game starts the game at level 1
Instructions displays the instructions for the game
High scores displays the high scores for the game in its current run
Level editor opens the level editor for the game
Return to main menu returns to the menu that allows the user to select a game
Quit quits the game (it works the same way here as above!)

(Arkanoidlevel)
Playing Arkaniod:
    Use the "A" and "D" keys to move the paddle and catch the ball before it
    falls past the bottom wall. Hit bricks to remove them and earn points. The
    ball bounces off non-bottom walls, the paddle, and bricks as it destroys
    them. When the ball moves pass the bottom wall, a new ball is created at the
    original ball starting position in the middle of the screen. Clear all
    bricks to advance to the next level.


(Tetrislevel)
Playing Tetris:
    As the pieces fall, use the left and right arrow keys to move the falling
    piece to the left or right. Use the up arrow to rotate the piece. Use the
    down key to make the piece fall more quickly. Complete a row of blocks to
    remove a row and cause all blocks above that row to shift down one row.
    Falling blocks cannot be moved past the side walls. Pieces cannot rotate if
    their rotation would cause them to intersect a wall or other blocks. A piece
    stops moving and falling when they land on blocks below them. Earn points by
    clearing rows. Clear 10 rows to advance a level. Falling speed of pieces
    increases with higher levels.




Framework classes for all games:

GameModel: 
    The role of GameModel is to coordinate between Actors, Physics,
    EventHandler, and the Canvas.
    GameModel will include:
        List of Actors
        EventHandler object
        Canvas object
        Game state information (score, player health, level)

    Behavior:   
    
    During each iteration of gametime, GameModel will be passed a list of keys
    the user presses by the Canvas through its update() method. Then it will
    call the act() method on each of its Actors using those keys as parameters.
    Then it will pass the list of Actors on to the CollisionDetection class
    which will check for collisions. Then it will pass the list of Actors to
    the EventHandler's handleEvents method. Finally its getActors() method
    returns a list of actors (called by the Drawer).

    Levels are initialized by the GameModel’s loadActors() method which will
    take a xml file which contains information on the Actors and their
    constructor parameters. This method can be called by other classes when
    switching levels.

The GameModel also contains a map of String -> Integer which store game
information specific to each game. These values will be initialized in the
initializeInfo() method and the update() and getInfo() methods update/retrieve
these values respectively. Different games which extend GameModel will override
the initializeInfo() method to account for whatever game state that game wants
recorded.

    The GameModel also contains a method makeShape(Actor) which given an Actor’s
    image and dimension creates a shape for it. This method is overridden by
    different games, as depending on the type of game the way an image is
    translated to a shape may be different (for example games that just use a
    normal canvas vs. a game that uses a grid).
    

Actor:
    The role of the Actor class is to store the state of and handle the behavior
    of individual objects in the game world.
    Actor will include:
        State information (Velocity, Acceleration, Position, Shape, Image,
        etc...)
        Behavior information 
Map of characters (keys pressed) -> Action objects
Map of Actors -> Actions
Map of boundaries -> Actions
        Default behavior (an Action object)
        
    Behavior:

    Each iteration of gametime, an Actor object's act() method will be called
    with a list of keys pressed by the user. The act method will first check to
    see if any of the keys pressed match the keys in its behavior map. If so, it
    will call any associated Action objects' execute() method with itself as a
    parameter. It will also call the execute() method of its default Action.

    Actor also has an interact() method which is called by CollisionDetector
    which takes another Actor and checks its map of interactions with other
    Actors and executes any applicable Actions. By convention each Actor is
    responsible for executing the Actions that apply to itself. 

    Actor also has a map of boundary actions which describe what the actor does
    when it encounters a boundary of the canvas (does it stop, bounce off, keep
    going, etc).

    Each of these behavior maps are initialized in different methods
    (initializeKeys, initializeInteractions, etc.) and are overridden by
    different subclasses of Actor.

    Actor also contains accessing methods for its state information, and a paint
    method which is used by the Canvas to paint it.

    
Action interface (and implementing classes):
    The role of the Action classes are to handle state changing behavior for the
    game. Each Action class will simulate a different type of action (Move,
    Accelerate, SwapImage, CreateActor, RemoveActor, etc...)
    
    Each class which implements Action must have an execute() method which takes
    some number of Actors (including none) and performs an action.

    When an Action object is instantiated, it will be given parameters in its
    constructors specifying details of its specific action. For example, an
    Accelerate object would be instantiated with the magnitude of the
    acceleration as a parameter. Or a SwapImage action would be instantiated
    with the new image as a parameter.
 
    We plan on providing a large library of Actions for use in other games.
    But if necessary a game designer using our engine could always add his own.

EventHandler:
    EventHandler's role is to handle special interactions and actions whose
    triggering conditions are not known by individual actors

    EventHandler will include:
        A map of conditions -> Actions

    Behavior:
    Each iteration of game-time, EventHandler will take in a list of Actors and
    a list of keys pressed as arguments of its handleEvents() method. It will
    then check to see if the evaluate() method of any of its conditions in its
    event map return true, if so it will perform any associated Actions.

    Actions that belong in EventHandler are things like the win-condition for
    arkanoid (which is triggered by there not being any bricks left, information
    which no individual brick knows). 

    EventHandler’s conditions map will be initialized by the initializeEvents
    method, which will take in a xml file with information on each Condition and
    Action.

Conditions:
    Conditions is an interface whose implementing classes implement the method
    evaluate() which returns a boolean. Conditions generally take a GameModel
    object as a parameter in its constructor, and uses the model’s getActors()
    and getInfo() methods to evaluate whether or not the condition its modeling
    returns true or false. 

    Like with Actions we plan on providing a large number of general conditions
    for game developers using our game engine to use, and more can be created as
    necessary.

Design of Arkanoid:

ArkanoidModel:
    The Arkanoid GameModel is just the basic one. The only information it
    records is the score.

Arkanoid Actors:
    Paddle: 
        Responds to ‘a’ and ‘d’ keys with the Move action moving it left or
        right respectively
        Interacts with powerups
            Lengthen/shortern paddle powerup -> SetSize
            Speed powerup -> Remove (to remove the current paddle), 
  Create (creates a   FastPaddle actor in the same location 
    Fast Paddle:
        Extension of Paddle with the Move actions instantiated with greater
        values

    Ball:
        Interacts with Paddle and Brick with the Bounce Action
        Boundary behavior:      
Bounces on left, right, and top boundaries
            EndGame on bottom boundary
        Default action – NaturalMove (move according to velocity and
        acceleration)
    Brick:
        Interactions:
            Ball ->     Remove
                Update (to update the score information in the GameModel)

EventHandler:
    Condition                   Action
    ActorCount (Bricks == 0)            SetLevel (calls GameModel’s
    initializeActor)
    
    Tetris design:
Required Actors:
    Left wall, Right wall, Bottom wall
        defaultbehavior is to do nothing
    FallingPieces
        defaultbehavior is to fall at a speed determined by the current level
        there will only be one FallingPiece at a time
    Blocks
        defaultbehavior is to do nothing
    Grid (maintains placeholders for valid spaces for Blocks. Allows for easy
    removal of full lines of Blocks and transformation of FallingPieces into
    smaller Blocks)
        defaultbehavior is to do nothing 

Collisions:
    FallingPiece/Wall: the falling piece is not allowed to move past this
    obstactle
    FallingPiece/Block: when a FallingPiece collides with a Block, it stops
    moving. At this point, all Grid areas occupied by the FallingPiece will get
    a new Brick, the existing FallingPiece is removed from the list of Actors,
    and the Grid checks to see if it has a full row (any row that has just added
    a Block is checked). If it does, it calls ClearRow on the full row(s).
    Block/Block, Block/Wall: won't really happen. When the Blocks are shifting
    down, they shift a set amount that will not actually cause them to collide,
    just come to rest next to

Other actions:
    MoveToSide: FallingPiece moves one unit to the left or right according to
    pressed arrow keys
    Rotate: When the up arrow is pressed, the current FallingPiece rotates by 90
    degrees, possibly by changing the image used to represent it? A piece is not
    allowed to rotate if such a rotation would cause it to intersect a Wall or a
    Block
    Drop: While the down arrow is pressed, the speed of the FallingPiece
    increases
    Speed Up: At level increase, the speed of FallingPieces becomes greater
    ClearRow: when a row becomes full (as determined by the Grid) all Blocks
    with positions in that row are removed from the list of Actors. All spaces
    in the Grid above this row are checked for Blocks, starting with the row
    above the cleared row and moving upward. All Blocks found should MoveDown
    one row for each row cleared. Grid checks for full rows again!
    MoveDown: moves a Block from its current row to the next row down


How to create a new game:
Edit MainMenu.properties
Create ArkanoidMenu.properties
Create any new Actors and Actions
    Each Actor needs to have a map of which Actions are applied for each
    possible collision that needs an Action
    Each Actor also needs to know its default behavior if any
    Also add any necessary image files
Create a GameModel 
Create level files 

EditorCanvas -
    Will have a MouseListener to record mouseclicks. When the user clicks on a location in the canvas, will create a popup box asking the user to type in the name of the Actor it would like to place there, and initial constructor parameters. 
    Then the EditorCanvas will repaint itself with the new Actor in place
Menu Buttons: 
    Save – Will convert the EditorCanvas into a xml file containing the actor information
    Load – Will open up a file chooser allowing the user to select a level file which will be displayed in the EditorCanvas
    Return to menu – Returns to the game menu
    Quit – Quits the program
    About – Displays instructions on how to use the editor

    